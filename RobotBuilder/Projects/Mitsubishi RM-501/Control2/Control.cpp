// Control.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "Control.h"

#include <dmSystem.hpp>
#include <dmIntegrator.hpp>
#include <dmEnvironment.hpp>
#include <RBUserIOData.h>

#include <dmLink.hpp>
#include <dmArticulation.hpp>
#include <dmu.h>

#include <sstream>

#include "type_def.h" // required for invkin method parameters

#define OUTPUTFILE "MitsuProject2.txt"  // The output file name

/*** PROTOTYPES ***/
extern "C" {void invkin(matx44 X, enum STATUS_SET STATUS, array6 ANG);}
void TranslatePulseUnitsToRadians (const int nJointAnglesInPulseUnits[], float JointAnglesInRadians[]);
void ComputeJointAngles (double dSimulationTimeInSeconds, int nJointAnglesInPulseUnits[], 
						 float fToolPosition[]);

/*** GLOBALS ***/
#define NUM_LINKS	7

/// Array of pointers to links in the system.
dmLink *g_pLinks[NUM_LINKS];
/// Used to determine when to output
int g_nLastTimeMSPrint = 0;
/// Used to know when to clear the output file.
bool g_bFirstTimeThroughControl = true;

/**
*
* DLL entry.
*
*/
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}

/**
*
* Called by RobotBuilder to intialize the controller
*
* @param pSystem a pointer to DynaMechs' representation of the system
*
* @param pRBUserIOData a pointer to the class that manages the user settable
*		IO capabilities during simulation mode
*
* @return a 1 to stop the simulation from occurring (used if the something in
*		the initialization function failed), otherwise return 0 (other values
*		reserved for future use).
*
*/

CONTROL_API int InitializeDMControl(dmSystem* pSystem, RBUserIOData *pRBUserIOData)
{
	// Make sure the pointer is not null
	if (!pSystem)
	{
		MessageBox (NULL, "pSystem NULL", "Error", MB_ICONERROR);
		return 1;
	}

	// Obtain pointer to articulation 
	// Note dmSystem is the parent of dmArticulation
	dmArticulation* pArticulation = (dynamic_cast <dmArticulation*> (pSystem));
	if (!pArticulation)
	{
		MessageBox (NULL, "pArticulation NULL", "Error", MB_ICONERROR);
		return 1;
	}

	// Find each of the links of interest.  The order is important, because the
	// joint values are applied expecting a certain order.
	g_pLinks[0] = dynamic_cast <dmLink*> (dmuFindObject ("body", pArticulation));
	g_pLinks[1] = dynamic_cast <dmLink*> (dmuFindObject ("upperarm", pArticulation));
	g_pLinks[2] = dynamic_cast <dmLink*> (dmuFindObject ("forearm", pArticulation));
	g_pLinks[3] = dynamic_cast <dmLink*> (dmuFindObject ("wrist_pitch", pArticulation));
	g_pLinks[4] = dynamic_cast <dmLink*> (dmuFindObject ("wrist_roll", pArticulation));
	g_pLinks[5] = dynamic_cast <dmLink*> (dmuFindObject ("gripper1", pArticulation));
	g_pLinks[6] = dynamic_cast <dmLink*> (dmuFindObject ("gripper2", pArticulation));

	// Verify the links were found
	int i;
	for (i = 0; i < NUM_LINKS; i++)
		if (!g_pLinks[i])
		{
			MessageBox (NULL, "Failed to find link", "Error", MB_ICONERROR);
			return 1;
		}

	bool bReturn;
	bReturn = pRBUserIOData->SetNumberOfOutputLists (1);
	if (!bReturn)
	{
		MessageBox (NULL, "SetNumberOfOutputLists Failed", "Error", MB_ICONERROR);
		return 1;
	}

	const int nPosX = 10;
	const int nPosY = 10;
	const int nWidth = 400;
	const int nHeight = 600;
	string strLabels; // Tab delimited labels
	strLabels = "Time\tPx\tPy\tPz\ta1\ta2\ta3\ta4\ta5";
	bReturn = pRBUserIOData->SetupOutputList (0, nPosX, nPosY, nWidth, nHeight, strLabels);
	if (!bReturn)
	{
		MessageBox (NULL, "SetupOutputList Failed", "Error", MB_ICONERROR);
		return 1;
	}

	return 0;
}

/**
*
* Called by RobotBuilder to let the control do clean up and resource deallocation.
*
* @param pSystem a pointer to DynaMechs' representation of the system
*
* @param pRBUserIOData a pointer to the class that manages the user settable
*		IO capabilities during simulation mode.  This function must
*		call CleanUp to deallocate User IO elements.
*
* @return 0 (other values reserved for future use)
*
*/
CONTROL_API int UninitializeDMControl(dmSystem* pSystem, RBUserIOData *pRBUserIOData)
{
	// Deallocate any UserIO elements
	pRBUserIOData->CleanUp ();

	return 0;
}

/**
*
* Called by RobotBuilder to compute the control for current state.
*	In this implementation, it uses the kinematic placement integrator.
*	The joint angles specified are generated by using the invkin method
*	to find joint angles from a desired transform.
*
* @param pIntegrator a pointer to the integrator used by DynaMechs
*
* @param pEnvironment a pointer to the DynaMechs' environment
*
* @param pRBUserIOData a pointer to the class that manages the user settable
*		IO capabilities during simulation mode 
*
* @param time the current simulation time
*
* @return a 1 to stop the simulation from occurring (used if the something in
*		the control function failed), otherwise return 0 (other values
*		reserved for future use)
*
*/
CONTROL_API int ComputeDMControl(dmSystem* pSystem, dmIntegrator* pIntegrator, 
								   dmEnvironment* pEnvironment, RBUserIOData *pRBUserIOData,
                           float fTime)

{
	float fJointAnglesInRadians[5];
	int nJointAnglesInPulseUnits[5];
	float fToolPosition[3];

	// Call student code to find the joint angles
	ComputeJointAngles (fTime, nJointAnglesInPulseUnits, fToolPosition);

	// Find in radians to set the articulation joints
	TranslatePulseUnitsToRadians (nJointAnglesInPulseUnits, fJointAnglesInRadians);

	int i;
	for (i = 0; i < 5; i++)
	{
		// Need to pass the data as a Float array (which in the current
		// DynaMechs build it typedefed to float, but to faciliate working
		// with double precision DynaMechs, I'll make a copy)
		Float q[1];
		q[0] = fJointAnglesInRadians[i];
		
		// Apply the joint positions - the state derivate doesn't matter, because
		// no integration is occurring, so just send a copy of the state to make
		// the compiler happy.
		g_pLinks[i]->setState (q, q);
	}


	// If first time through, erase the old output file and start over
	if (g_bFirstTimeThroughControl)
	{
		g_bFirstTimeThroughControl = false;
		// Clear the output file by overwriting the whole file with a new header
		ofstream strmOut;
		string strOutputFile = pRBUserIOData->GetProjectDirectory () + '\\' + OUTPUTFILE;
		strmOut.open (strOutputFile.c_str ());
		strmOut << 
			"                             Project 2" << endl << endl;
		strmOut <<
			"Time    Px      Py      Pz      a1      a2      a3      a4      a5" << endl;
		strmOut <<
			"----   -----   -----   -----   -----   -----   -----   -----   -----" << endl;
		strmOut.close ();
	}

	// Output the data at the beginning
	if (fTime < 3.2)
	{
		// Only output the data every 50ms, but try to be somewhat robust, in case this
		// is hit at non-50ms intervals
		int nTimeMS = (int) (fTime * 1000 + .5f); // Round time the closest ms
		if (nTimeMS >= g_nLastTimeMSPrint + 50)
		{
			g_nLastTimeMSPrint = nTimeMS;
			ofstream strmOut;
			// Open the file in append mode
			string strOutputFile = pRBUserIOData->GetProjectDirectory () + '\\' + OUTPUTFILE;
			strmOut.open (strOutputFile.c_str (), ios::app);

			int nIsOpen = strmOut.is_open ();
			if (!nIsOpen)
			{
				MessageBox (NULL, "Failed to open output file", "Error", MB_ICONERROR);
				return 1;
			}

 			// Set output format to fixed (not scientific) and right aligned
			strmOut.flags (ios::fixed | ios::right);

			strmOut << setprecision (2) << setw (3) << fTime << "   " << setprecision(1) << 
				setw(5) << fToolPosition[0] << "   " << 
				setw(5) << fToolPosition[1] << "   " <<
				setw(5) << fToolPosition[2] << "   ";
			for (i= 0; i < 5; i++)
				strmOut << setw(5) << setprecision(0) << nJointAnglesInPulseUnits[i] << "   ";

			strmOut << endl;

			strmOut.close ();

			//// Display in output control too
			// Build the string to output to
			ostringstream strmData; // Holds the value to send to the UserIO
			strmData.flags (ios::fixed);

			strmData << setprecision (2) << setw (3) << fTime << '\t' << setprecision(1) << 
				setw(5) << fToolPosition[0] << '\t' << 
				setw(5) << fToolPosition[1] << '\t' <<
				setw(5) << fToolPosition[2] << '\t';
			for (i= 0; i < 4; i++)
				strmData << setw(5) << setprecision(0) << nJointAnglesInPulseUnits[i] << '\t';
			strmData << setw(5) << setprecision(0) << nJointAnglesInPulseUnits[4] << ends;

			bool bReturn;
			bReturn = pRBUserIOData->SetOutputListData (0, strmData.str ());
			if (!bReturn)
			{
				MessageBox (NULL, "SetOutputList Failed", "Error", MB_ICONERROR);
				return 1;
			}
		}
	}


	return 0;
}

/**
*
* Passes keypresses captured in RobotBuilder during simulation and passes them
*	to control algorithm to provide interactive control (like tuning gains).
*
* @param nChar the character pressed
*
* @param nRepCnt the number of times the character has been pressed since the
*	system last told control about the key press (implements typematic)
*
* @return 0 (other values reserved for future use)
*
*/
CONTROL_API int HandleKeyPress (UINT nChar, int nRepCnt)
{
	return 0;
}


/**
*
* Wrapper for Dr. Orin's invkin.  This function provides an interface to
*	that function, so the student code section will follow the same naming
*	and variable convections used throughout the project
*
* @param fTransform a 4x4 input array that contains the desired transform
* @param nJointAnglesInPulseUnits an output array of 5 ints that will receive
*	the joint angles (in pulse units) needed to attain the inputted transform.
*
*/
void InverseKinematics (const float fTransform[][4], int nJointAnglesInPulseUnits[])
{
	// It looks like the invkin.c code was translated from Pascal and so some
	// things don't make sense
	enum STATUS_SET status = VALID_SOLUTION; // This is not used, probably was
		// a return value in Pascal
	int nJointAnglesFromInvKin[6]; // The invkin returns the joint angles
		// in an array of six elements (last not used), so I need to allocate that much 
		// to prevent a buffer overflow, then copy the result to return.
	matx44 mat;	// Copy into non-const
	for (int i = 0; i < 4; i++)
		for (int j = 0; j < 4; j++)
			mat[i][j] = fTransform[i][j];

	invkin (mat, status, nJointAnglesFromInvKin);

	// Copy the returned values to the five element array to return
	for (i = 0; i < 5; i++)
		nJointAnglesInPulseUnits[i] = nJointAnglesFromInvKin[i];
}

